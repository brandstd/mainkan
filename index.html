
<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Player</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: black;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: black;
    }

    /* Video Elements */
    #videoPlayer, #mjpegPlayer, #webrtcFrame {
      max-width: 100%;
      max-height: 100%;
      width: 100%;
      height: auto;
      object-fit: contain;
      background: black;
      display: none;
    }

    #webrtcFrame {
      width: 100vw;
      height: 100vh;
      border: none;
    }

    video-stream {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      background: black;
      display: block;
    }

    #error {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(40, 40, 40, 0.95);
      color: #ffdddd;
      padding: 20px 24px;
      border-radius: 8px;
      font-size: 16px;
      text-align: center;
      z-index: 10000;
      display: none;
      max-width: 80%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    #offline {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.95);
      color: #ff6b6b;
      padding: 20px;
      width: 60%;
      border-radius: 12px;
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      z-index: 10001;
      display: none;
      border: 2px solid #ff6b6b;
      box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      text-align: center;
      z-index: 9998;
      display: block;
    }

    .spinner {
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top: 3px solid #fff;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Instructions */
    #instructions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      text-align: center;
      z-index: 9997;
      padding: 20px;
      max-width: 80%;
      display: none;
    }

    .url-example {
      background: rgba(255, 255, 255, 0.1);
      padding: 8px 12px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 14px;
      margin: 5px 0;
      word-break: break-all;
    }
  </style>
</head>
<body>
  <div id="container">
    <video id="videoPlayer" autoplay muted playsinline></video>
    <img id="mjpegPlayer" alt="MJPEG Stream">
    <iframe id="webrtcFrame" allow="autoplay; fullscreen; camera; microphone"></iframe>
  </div>

  <div id="loading">
    <div class="spinner"></div>
    <div>Memuat Video...</div>
  </div>

  <div id="instructions">
    <h2>ðŸŽ¥ Player</h2>
  </div>


  <div id="error" role="alert"></div>
  <div id="offline">ðŸ“¡ CCTV SEDANG OFFLINE</div>

  <!-- External Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/flv.js@1.6.2/dist/flv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

  <script type="module">
    class UniversalPlayer {
      constructor() {
        this.currentPlayer = null;
        this.currentType = null;

        this.errorEl = document.getElementById('error');
        this.offlineEl = document.getElementById('offline');
        this.loadingEl = document.getElementById('loading');
        this.instructionsEl = document.getElementById('instructions');
        this.videoEl = document.getElementById('videoPlayer');
        this.mjpegEl = document.getElementById('mjpegPlayer');
        this.webrtcEl = document.getElementById('webrtcFrame');
        this.container = document.getElementById('container');
        
        this.mjpegInterval = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 3;
        this.timeoutId = null;
        
        this.init();
      }





      showOffline() {
        this.hideLoading();
        this.hideError();
        this.offlineEl.style.display = 'block';
      }

      hideOffline() {
        this.offlineEl.style.display = 'none';
      }

      showError(message) {
        this.hideLoading();
        this.hideOffline();
        this.errorEl.textContent = message;
        this.errorEl.style.display = 'block';
      }

      hideError() {
        this.errorEl.style.display = 'none';
      }

      hideElements() {
        this.videoEl.style.display = 'none';
        this.mjpegEl.style.display = 'none';
        this.webrtcEl.style.display = 'none';
        this.errorEl.style.display = 'none';
        this.offlineEl.style.display = 'none';
        this.instructionsEl.style.display = 'none';
      }

      showLoading(message = 'Loading...') {
        this.loadingEl.querySelector('div:last-child').textContent = message;
        this.loadingEl.style.display = 'block';
      }

      hideLoading() {
        this.loadingEl.style.display = 'none';
      }

      showInstructions() {
        this.instructionsEl.style.display = 'block';
        this.hideLoading();
      }

      hideInstructions() {
        this.instructionsEl.style.display = 'none';
      }

      hideAllPlayers() {
        this.videoEl.style.display = 'none';
        this.mjpegEl.style.display = 'none';
        this.webrtcEl.style.display = 'none';
        
        // Clear any existing video-stream elements
        const existingStreams = this.container.querySelectorAll('video-stream');
        existingStreams.forEach(el => el.remove());
      }

      cleanup() {
        this.hideError();
        this.hideAllPlayers();
        this.hideOffline();
        
        if (this.mjpegInterval) {
          clearInterval(this.mjpegInterval);
          this.mjpegInterval = null;
        }

        if (this.currentPlayer) {
          try {
            if (this.currentType === 'flv' && this.currentPlayer.destroy) {
              this.currentPlayer.destroy();
            } else if (this.currentType === 'hls' && this.currentPlayer.destroy) {
              this.currentPlayer.destroy();
            }
          } catch (e) {
            console.warn('Cleanup error:', e);
          }
          this.currentPlayer = null;
        }

        this.currentType = null;
        this.reconnectAttempts = 0;
      }

      detectStreamType(url) {
        const urlLower = url.toLowerCase();
        
        // YouTube Live streams
        if (urlLower.includes('youtube.com') || urlLower.includes('youtu.be')) {
          return 'youtube';
        }
        
        // WebSocket streams
        if (url.startsWith('wss://') || url.startsWith('ws://')) {
          return 'websocket';
        }
        
        // WebRTC or iframe content
        if (url.includes('webrtc') || url.includes('rtc') || 
            (url.startsWith('http') && (url.includes('player') || url.includes('stream.html')))) {
          return 'webrtc';
        }
        
        // Image/MJPEG streams - Enhanced detection
        if (urlLower.includes('.jpg') || urlLower.includes('.jpeg') || 
            urlLower.includes('.png') || urlLower.includes('mjpeg') || 
            urlLower.includes('snapshot') || urlLower.includes('/img') ||
            // ZoneMinder and other CGI-based MJPEG streams
            urlLower.includes('nph-zms') || urlLower.includes('/zm/') ||
            urlLower.includes('cgi-bin') && (urlLower.includes('monitor=') || urlLower.includes('cam=')) ||
            // Other common MJPEG patterns
            urlLower.includes('mjpg') || urlLower.includes('image.cgi') ||
            urlLower.includes('video.cgi') && urlLower.includes('resolution=') ||
            urlLower.includes('axis-cgi') || urlLower.includes('/jpg/') ||
            // Motion and other surveillance software
            urlLower.includes('/motion/') || urlLower.includes('stream.jpg') ||
            // IP Camera common patterns
            (urlLower.includes('cgi') && (urlLower.includes('jpg') || urlLower.includes('image'))) ||
            // Query parameters that suggest MJPEG
            (urlLower.includes('?') && (urlLower.includes('scale=') || urlLower.includes('quality='))) && 
            !urlLower.includes('.flv') && !urlLower.includes('.m3u8') && !urlLower.includes('.mp4')) {
          return 'mjpeg';
        }
        
        // Video formats
        if (urlLower.includes('.flv')) return 'flv';
        if (urlLower.includes('.m3u8')) return 'hls';
        if (urlLower.includes('.mp4') || urlLower.includes('.webm') || 
            urlLower.includes('.ogv') || urlLower.includes('.mpeg')) return 'native';
        
        // Stream.html format detection
        if (url.includes('stream.html') || url.includes('src=') || url.includes('mode=')) {
          return 'websocket';
        }
        
        // Default fallback
        return 'native';
      }

      async loadWebSocketModules() {
        console.log('Attempting to load WebSocket modules...');
        const pairs = [
          ['./js/video-stream.js', './js/video-rtc.js'],
          [location.origin + location.pathname.replace(/\/[^/]*$/, '/') + 'js/video-stream.js', 
           location.origin + location.pathname.replace(/\/[^/]*$/, '/') + 'js/video-rtc.js'],
          ['https://kertrtc.etnvps.click/video-stream.js', 'https://kertrtc.etnvps.click/video-rtc.js'],
          ['https://alexxit.github.io/go2rtc/video-stream.js']
        ];

        for (const pair of pairs) {
          try {
            console.log('Trying to load modules from:', pair);
            for (const url of pair) {
              if (url) {
                console.log('Loading:', url);
                await import(url);
              }
            }
            console.log('Successfully loaded modules from:', pair);
            return true;
          } catch (err) {
            console.warn('Failed to load modules from', pair, err.message);
          }
        }
        console.log('All module loading attempts failed, using fallback');
        return false;
      }

      playWebSocket(url) {
        console.log('playWebSocket called with URL:', url);
        
        // Skip module loading and go directly to fallback
        console.log('Using native MSE fallback directly');
        this.playWebSocketFallback(url);
      }

      playWebSocketWithModule(url) {
        // Parse URL similar to wss-player2.html logic
        let streams = [];
        let modes = [];
        let baseForApi = null;

        if (url.startsWith('wss://') || url.startsWith('ws://')) {
          streams = [url];
          modes = ['mse'];
        } else if (url.includes('stream.html')) {
          const u = new URL(url);
          baseForApi = u.origin;
          const params = u.searchParams;
          streams = params.getAll('src') || [params.get('src')].filter(Boolean);
          modes = params.getAll('mode') || ['mse'];
        } else if (url.includes('src=')) {
          const params = new URLSearchParams(url);
          streams = params.getAll('src') || [params.get('src')].filter(Boolean);
          modes = params.getAll('mode') || ['mse'];
        } else {
          streams = [url];
          modes = ['mse'];
          baseForApi = 'https://kertrtc.etnvps.click';
        }

        // Create video-stream element
        const vid = document.createElement('video-stream');
        vid.setAttribute('playsinline', 'true');
        vid.setAttribute('autoplay', 'true');
        vid.setAttribute('muted', 'true');
        vid.autoplay = true;
        vid.muted = true;
        vid.background = true;

        let srcToUse = streams[0];
        if (!(srcToUse.startsWith('wss://') || srcToUse.startsWith('ws://') || 
              srcToUse.startsWith('http://') || srcToUse.startsWith('https://'))) {
          if (baseForApi) {
            srcToUse = baseForApi + '/api/ws?src=' + encodeURIComponent(srcToUse);
          } else {
            srcToUse = 'https://kertrtc.etnvps.click/api/ws?src=' + encodeURIComponent(srcToUse);
          }
        }

        vid.mode = modes[0] || 'mse';
        vid.src = srcToUse;

        this.container.appendChild(vid);
        this.currentPlayer = vid;
        this.currentType = 'websocket';

        // Set 10-second timer to auto-hide loading if no response
        let loadingTimeout = setTimeout(() => {
          this.hideLoading();
          loadingTimeout = null;
        }, 10000);

        // Event listeners
        vid.addEventListener('playing', () => {
          if (loadingTimeout) {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
          }
          this.hideLoading();
        });

        vid.addEventListener('error', () => {
          if (loadingTimeout) {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
          }
          this.showOffline();
        });

        vid.addEventListener('abort', () => {
          if (loadingTimeout) {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
          }
          this.showOffline();
        });

        vid.addEventListener('stalled', () => {
          this.showOffline();
        });
      }

      playWebSocketFallback(url) {
        console.warn('Menggunakan native MSE WebSocket player:', url);
        
        // Create video element for MSE playback
        const video = document.createElement('video');
        video.setAttribute('autoplay', 'true');
        video.setAttribute('muted', 'true');
        video.setAttribute('playsinline', 'true');
        video.autoplay = true;
        video.muted = true;
        video.playsInline = true;
        video.style.cssText = `
          width: 100%;
          height: 100%;
          object-fit: contain;
          background: black;
        `;
        
        this.container.appendChild(video);
        this.currentPlayer = video;
        this.currentType = 'websocket';
        
        // Add click handler for manual play if autoplay fails
        const playOnClick = () => {
          video.play().catch(e => console.warn('Manual play failed:', e));
          document.removeEventListener('click', playOnClick);
          document.removeEventListener('touchstart', playOnClick);
        };
        document.addEventListener('click', playOnClick, { once: true });
        document.addEventListener('touchstart', playOnClick, { once: true });

        // Check MediaSource support
        if (!window.MediaSource) {
          console.error('MediaSource tidak didukung di browser ini');
          this.showOffline();
          return;
        }

        // MSE variables
        let mseQueue = [];
        let mseSourceBuffer;
        let mseStreamingStarted = false;
        let currentWs = null;
        let mse = new MediaSource();

        video.src = window.URL.createObjectURL(mse);
        console.log('MSE URL created:', video.src);

        // Set 15-second timer to auto-hide loading if no response
        let loadingTimeout = setTimeout(() => {
          this.hideLoading();
          this.showOffline();
          if (currentWs) {
            currentWs.close();
          }
        }, 15000);
        
        // Track data reception
        let lastDataTime = Date.now();
        let dataCheckInterval = setInterval(() => {
          const now = Date.now();
          if (now - lastDataTime > 10000) { // No data for 10 seconds
            this.showOffline();
            if (currentWs) {
              currentWs.close();
            }
            clearInterval(dataCheckInterval);
          }
        }, 5000);

        // MSE event handlers
        const pushPacket = () => {
          if (!mseSourceBuffer.updating && mseQueue.length > 0) {
            try {
              const packet = mseQueue.shift();
              mseSourceBuffer.appendBuffer(packet);
            } catch (e) {
              console.error('Error appending buffer:', e);
              // Clear queue on error
              mseQueue = [];
              mseStreamingStarted = false;
            }
          } else {
            mseStreamingStarted = false;
          }
        };

        const readPacket = (packet) => {
          if (!mseSourceBuffer) {
            return;
          }
          
          if (!mseStreamingStarted) {
            try {
              mseSourceBuffer.appendBuffer(packet);
              mseStreamingStarted = true;
              
              // Clear loading and try to play
              if (loadingTimeout) {
                clearTimeout(loadingTimeout);
                loadingTimeout = null;
              }
              this.hideLoading();
              
              // Multiple attempts to play video
              const attemptPlay = async () => {
                try {
                  await video.play();
                  console.log('Video auto-play berhasil');
                } catch (e) {
                  console.warn('Auto-play gagal, menunggu interaksi user:', e.message);
                  // Show a subtle hint for user interaction
                  if (!document.querySelector('.play-hint')) {
                    const hint = document.createElement('div');
                    hint.className = 'play-hint';
                    hint.style.cssText = `
                      position: fixed;
                      bottom: 20px;
                      left: 50%;
                      transform: translateX(-50%);
                      background: rgba(0,0,0,0.8);
                      color: white;
                      padding: 10px 20px;
                      border-radius: 20px;
                      font-size: 14px;
                      z-index: 10000;
                      animation: fadeInOut 3s ease-in-out;
                    `;
                    hint.textContent = 'ðŸ‘† Tap untuk memulai video';
                    document.body.appendChild(hint);
                    
                    // Add CSS animation
                    if (!document.querySelector('#play-hint-style')) {
                      const style = document.createElement('style');
                      style.id = 'play-hint-style';
                      style.textContent = `
                        @keyframes fadeInOut {
                          0%, 100% { opacity: 0; }
                          50% { opacity: 1; }
                        }
                      `;
                      document.head.appendChild(style);
                    }
                    
                    setTimeout(() => hint.remove(), 3000);
                  }
                }
              };
              
              // Try to play immediately
              attemptPlay();
              
              // Also try when video has enough data
              video.addEventListener('canplay', attemptPlay, { once: true });
              video.addEventListener('loadeddata', attemptPlay, { once: true });
            } catch (e) {
              console.error('Error starting MSE streaming:', e);
            }
            return;
          }
          
          mseQueue.push(packet);
          if (!mseSourceBuffer.updating) {
            pushPacket();
          }
        };

        mse.addEventListener('sourceopen', () => {
          if (loadingTimeout) {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
          }
          
          if (currentWs) currentWs.close();
          if (mseSourceBuffer) {
            try {
              mseSourceBuffer.abort();
              mse.removeSourceBuffer(mseSourceBuffer);
            } catch (e) {
              // Ignore removal errors
            }
            mseQueue = [];
            mseStreamingStarted = false;
          }


          
          // Add connection retry mechanism
          let retryCount = 0;
          const maxRetries = 3;
          
          const connectWebSocket = () => {
            const ws = new WebSocket(url);
             currentWs = ws;
             ws.binaryType = 'arraybuffer';
             
             // Connection timeout
             const connectionTimeout = setTimeout(() => {
               if (ws.readyState === WebSocket.CONNECTING) {
                 ws.close();
               }
             }, 5000);
             
             ws.onopen = () => {
               clearTimeout(connectionTimeout);
               retryCount = 0; // Reset retry count on successful connection
             };
            
            ws.onerror = (error) => {
               clearTimeout(connectionTimeout);
               
               if (retryCount < maxRetries) {
                 retryCount++;
                 setTimeout(connectWebSocket, 2000);
                 return;
               }
               
               if (loadingTimeout) {
                 clearTimeout(loadingTimeout);
                 loadingTimeout = null;
               }
               if (dataCheckInterval) {
                 clearInterval(dataCheckInterval);
               }
               this.hideLoading();
               this.showOffline();
             };
             
             ws.onclose = (event) => {
               clearTimeout(connectionTimeout);
               
               if (event.code !== 1000 && retryCount < maxRetries) { // Not normal closure
                 retryCount++;
                 setTimeout(connectWebSocket, 2000);
                 return;
               }
               
               if (loadingTimeout) {
                 clearTimeout(loadingTimeout);
                 loadingTimeout = null;
               }
               if (dataCheckInterval) {
                 clearInterval(dataCheckInterval);
               }
               this.hideLoading();
               this.showOffline();
             };
            
            return ws;
          };
          
          const ws = connectWebSocket();

          ws.onmessage = (event) => {
            lastDataTime = Date.now(); // Update last data time
            const data = new Uint8Array(event.data);
            
            if (data[0] === 9) {
              const decoded = data.slice(1);
              let mimeCodec = 'video/mp4; codecs="avc1.42E01E"';
              try {
                mimeCodec = 'video/mp4; codecs="' + new TextDecoder('utf-8').decode(decoded) + '"';
              } catch (e) {
                // Use fallback codec
              }
              try {
                mseSourceBuffer = mse.addSourceBuffer(mimeCodec);
                mseSourceBuffer.mode = 'segments';
                
                mseSourceBuffer.addEventListener('updateend', () => {
                  pushPacket();
                });
                
                mseSourceBuffer.addEventListener('error', (e) => {
                  console.error('SourceBuffer error:', e);
                });
                
              } catch (e) {
                console.error('Error creating SourceBuffer:', e);
                this.showOffline();
              }
            } else {
              readPacket(event.data);
            }
          };
        });

        // Video event listeners with enhanced auto-play
        video.addEventListener('canplay', () => {
          if (loadingTimeout) {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
          }
          this.hideLoading();
          
          // Try to play when video is ready
          video.play().catch(e => {
            console.warn('Auto-play pada canplay gagal:', e.message);
          });
        });
        
        video.addEventListener('playing', () => {
          if (loadingTimeout) {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
          }
          this.hideLoading();
          
          // Remove play hint if video is playing
          const hint = document.querySelector('.play-hint');
          if (hint) hint.remove();
        });
        
        video.addEventListener('loadedmetadata', () => {
          // Try to play when metadata is loaded
          video.play().catch(e => {
            console.warn('Auto-play pada loadedmetadata gagal:', e.message);
          });
        });

        video.addEventListener('error', (e) => {
          console.error('Video error:', e, video.error);
          if (loadingTimeout) {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
          }
          this.hideLoading();
          this.showOffline();
        });
      }

      async playFLV(url) {
        if (!window.flvjs || !flvjs.isSupported()) {
          throw new Error('Browser tidak mendukung FLV atau flv.js tidak tersedia');
        }

        this.videoEl.style.display = 'block';
        
        const player = flvjs.createPlayer({
          type: 'flv',
          url: url
        }, {
          enableStashBuffer: false,
          isLive: true
        });

        player.attachMediaElement(this.videoEl);
        player.load();
        
        this.currentPlayer = player;
        this.currentType = 'flv';

        player.on(flvjs.Events.ERROR, (errorType, errorDetail) => {
          console.error('FLV Error:', errorType, errorDetail);
          this.showOffline();
        });

        this.videoEl.addEventListener('loadstart', () => {
          this.hideLoading();
          // Try auto-play for FLV
          this.videoEl.play().catch(e => {
            console.warn('FLV auto-play gagal:', e.message);
          });
        });
        
        this.videoEl.addEventListener('canplay', () => {
          // Try auto-play when FLV is ready
          this.videoEl.play().catch(e => {
            console.warn('FLV auto-play pada canplay gagal:', e.message);
          });
        });
        
        this.videoEl.addEventListener('error', () => {
          this.showOffline();
        });

        this.videoEl.addEventListener('abort', () => {
          this.showOffline();
        });

        this.videoEl.addEventListener('stalled', () => {
          this.showOffline();
        });

        await player.play();
      }

      async playHLS(url) {
        this.videoEl.style.display = 'block';

        if (Hls.isSupported()) {
          const hls = new Hls();
          this.currentPlayer = hls;
          this.currentType = 'hls';

          hls.loadSource(url);
          hls.attachMedia(this.videoEl);

          hls.on(Hls.Events.MANIFEST_PARSED, async () => {
            this.hideLoading();
            try {
              await this.videoEl.play();
              console.log('HLS auto-play berhasil');
            } catch (e) {
              console.warn('HLS auto-play gagal:', e.message);
            }
          });

          hls.on(Hls.Events.ERROR, (event, data) => {
            console.error('HLS Error:', data);
            if (data.fatal) {
              this.showOffline();
            }
          });

          this.videoEl.addEventListener('error', () => {
            this.showOffline();
          });

          this.videoEl.addEventListener('abort', () => {
            this.showOffline();
          });

          this.videoEl.addEventListener('stalled', () => {
            this.showOffline();
          });
        } else if (this.videoEl.canPlayType('application/vnd.apple.mpegurl')) {
          this.videoEl.src = url;
          try {
            await this.videoEl.play();
            console.log('Native HLS auto-play berhasil');
          } catch (e) {
            console.warn('Native HLS auto-play gagal:', e.message);
          }
        } else {
          throw new Error('Browser tidak mendukung HLS');
        }
      }

      async playNative(url) {
        this.videoEl.style.display = 'block';
        this.videoEl.src = url;
        this.currentType = 'native';

        this.videoEl.addEventListener('loadedmetadata', () => {
          this.hideLoading();
          // Try auto-play when metadata is loaded
          this.videoEl.play().catch(e => {
            console.warn('Native video auto-play gagal:', e.message);
          });
        });

        this.videoEl.addEventListener('error', () => {
          this.showOffline();
        });

        this.videoEl.addEventListener('abort', () => {
          this.showOffline();
        });

        this.videoEl.addEventListener('stalled', () => {
          this.showOffline();
        });

        await this.videoEl.play();
      }

      playMJPEG(url) {
        this.mjpegEl.style.display = 'block';
        this.currentType = 'mjpeg';

        let isFirstLoad = true;
        let loadingTimeout;

        // Set up event handlers once - outside of refresh function
        this.mjpegEl.onerror = () => {
          if (loadingTimeout) {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
          }
          this.showOffline();
        };

        this.mjpegEl.onload = () => {
          if (loadingTimeout) {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
          }
          if (isFirstLoad) {
            this.hideLoading();
            isFirstLoad = false;
          }
        };

        const refreshImage = () => {
          const urlWithTimestamp = url + (url.includes('?') ? '&' : '?') + 'ts=' + Date.now();
          this.mjpegEl.src = urlWithTimestamp;
        };

        // Set 10-second timer to auto-hide loading if no response
        loadingTimeout = setTimeout(() => {
          this.hideLoading();
          isFirstLoad = false;
          loadingTimeout = null;
        }, 10000);

        // Initial load
        refreshImage();
        
        // Set interval exactly like img-player.html
        this.mjpegInterval = setInterval(refreshImage, 3000);
      }

      playWebRTC(url) {
        this.webrtcEl.style.display = 'block';
        this.webrtcEl.src = url;
        this.currentType = 'webrtc';

        this.webrtcEl.onload = () => {
          this.hideLoading();
        };

        this.webrtcEl.onerror = () => {
          this.showOffline();
        };
      }

      playYouTube(url) {
        this.webrtcEl.style.display = 'block';
        this.currentType = 'youtube';

        // Extract video ID from various YouTube URL formats
        let videoId = '';
        
        if (url.includes('youtube.com/watch?v=')) {
          videoId = url.split('v=')[1].split('&')[0];
        } else if (url.includes('youtu.be/')) {
          videoId = url.split('youtu.be/')[1].split('?')[0];
        } else if (url.includes('youtube.com/embed/')) {
          videoId = url.split('embed/')[1].split('?')[0];
        } else if (url.includes('youtube.com/live/')) {
          videoId = url.split('live/')[1].split('?')[0];
        }

        if (!videoId) {
          this.showError('URL YouTube tidak valid');
          return;
        }

        // Create YouTube embed URL with live stream parameters
        const embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=1&rel=0&modestbranding=1&playsinline=1`;
        
        this.webrtcEl.src = embedUrl;

        // Set 10-second timer to auto-hide loading if no response
        let loadingTimeout = setTimeout(() => {
          this.hideLoading();
          loadingTimeout = null;
        }, 10000);

        this.webrtcEl.onload = () => {
          if (loadingTimeout) {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
          }
          this.hideLoading();
        };

        this.webrtcEl.onerror = () => {
          if (loadingTimeout) {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
          }
          this.showOffline();
        };
      }



      async playStream(url) {
        this.cleanup();
        this.hideInstructions();
        this.showLoading('Mendeteksi format stream...');

        try {
          const streamType = this.detectStreamType(url);

          this.showLoading('Memuat player...');

          switch (streamType) {
            case 'websocket':
              await this.playWebSocket(url);
              break;
            case 'flv':
              await this.playFLV(url);
              break;
            case 'hls':
              await this.playHLS(url);
              break;
            case 'mjpeg':
              this.playMJPEG(url);
              break;
            case 'webrtc':
              this.playWebRTC(url);
              break;
            case 'youtube':
              this.playYouTube(url);
              break;
            case 'native':
            default:
              await this.playNative(url);
              break;
          }

          // Setup common video events
          if (this.videoEl.style.display === 'block') {
            this.videoEl.addEventListener('playing', () => {
              this.hideLoading();
            });

            this.videoEl.addEventListener('waiting', () => {
              // Video is buffering
            });
          }



        } catch (error) {
          console.error('Playback error:', error);
          this.showError(error.message || 'Gagal memutar stream');
        }
      }

      init() {
        // Parse URL hash
        const hash = window.location.hash.substring(1);
        const url = hash ? decodeURIComponent(hash) : '';

        if (!url) {
          this.showInstructions();
          return;
        }

        this.playStream(url);

        // Listen for hash changes
        window.addEventListener('hashchange', () => {
          const newHash = window.location.hash.substring(1);
          const newUrl = newHash ? decodeURIComponent(newHash) : '';
          
          if (newUrl) {
            this.playStream(newUrl);
          } else {
            this.cleanup();
            this.showInstructions();
          }
        });
      }
    }

    // Initialize the universal player
    const player = new UniversalPlayer();
  </script>
</body>
</html>
